(ns advent-of-code-2018.dec18
  (:require [clojure.string :as str])
  (:require [clojure.set :as set]))

(def input ".|||.#..|##.#||..#.|..|..||||..#|##.##..#...|.....
.|#.|#..##...|#.........#.#..#..|#.|#|##..#.#|..#.
#....#|.#|.###||..#.|...|.|.#........#.|.#.#|..#..
|..|#....|#|...#.#..||.#..||......#.........|....|
.|.|..#|...#.|.###.|...||.|.|..|...|#|.#..|.|..|.|
#.....||.#..|..|..||#.||#..|.||..||##.......#.....
||.#..........|....##...|..#.|..#..#|#.#....#..#.#
.#.#|.|.|.##|..#......|...#||..#.||..|..|#....|##.
#.#..||.|...#|...|..#.#.||#.||.#.|.....|##.|....#.
.#......||.|#......#|#.|...||...||##...#...####.#.
.....#..|..#..#|..#...#.|#...||...#.##.||.|..|.||.
.#|.#.|.....|#..#||..|...|...##.#.###|..|.###.|#..
..#.......#.|#.##....#..|##.#......#|......#..#...
.|..#|.#.....#..||..#.#.|##..|#.||#..|.#..|.|##|#|
##|.#........|#.#.#|..|....|.......#..#|.#.|....#.
....##...|....#..............||.|..#........|.....
##||.|.#...|.#|..#....#..|...|..#..#..|##||.....|.
.|.#...|#.......#...#.#..|#....#|#|#..#|...##..||.
.|..|.|..#...##...||#..##|#|..|...#.....#||...##..
.|...|..||#..#|.|.#...|||.|#.||#|......|#|.#..|#..
|##.....|.|#...#||.....#..#.|.#..|.....||....||..#
|.|#|||.....|||..#......#..||........||.#.#..||#||
#.|.|.#.....#....#.#..#||.||..|.#.|....|...#.#...#
|.|....#.#||...#.....#|#|.|.#......##.|.||...#.||.
|...|...|##........|.|...#...|.........|..##..|.##
|.||..|.#.#|.#||...|.|.....#...#.####|.||||..|||.|
.....#..##..|..#|.||#...|..##...##|....##||.##....
#|##..#|.#..|##...|..#.##.|##.....###.|..#.|..#.|.
|.##..|#...|.|.||.......#..#||.....#|..#||##..#|..
..|.#.#.....##.|#|...#........##......#...#...||..
|.#....###|..|##.#...#|....|..#.....#.##.|..|...||
.....#..#.....|.##......#......|..|...##|.|.#..#||
...##.#.......#|.#..||.#|..#|...#...|||.#.......|#
#|..#|....|||...|..#|....#......#..#...|#.......||
...#|##|..........|..###||..#|...|.##.|.#.#...#...
#|##|.#|#...|..#......||..#.|#|..#..|..#|..#......
#||#.#.....|...|..|##|..#|...##.||..#|.|#||.|..|..
#..#..|.|.||...#|.|.|..|..|..|....#.#||.#.....|#.#
#.|.#..##...|..#.|..#..#..#.#||.#.............#...
..|##|.#|.|......|#...|#.#.....|#|#.#.|...|#......
.|.|.|...#..##..#|###..|#....#..#.#..|||.###|##...
|#...|......|...##..|.|#...#..|.#.........#..##.#.
.|...##||#.....#..#..|..#..#.|#.|.||.##.|....|..#|
|#..|..|.#..||...#...#|..##|||##..|.##||#.#.|....|
.......#......|.....||.#..|#.#.#|#.##....|...|.#..
.....#..|...|..##.....|...#...|.|||.##..|.#||.##|.
..#||...|#.#|#|....#..|||.|##..#|.|.........|....#
..#...|.#...|#..#........#...###..##..##||...|..#.
..|.||.#.....|#..|.##...#.|...|#...#||..####..#.|.
.|.....#....||.#...#.......#|........#...#|#|...|#")

(def input-small ".#.#...|#.
.....#|##|
.|..|...#.
..|#.....#
#.#|||#|#|
...#.||...
.|....|...
||...#|.#|
|.||||..|.
...#.|..|.")

(defn forest-to-outcome
  [forest]
  (apply * (map #(count (second %)) (filter #(or (= (first %) "|") (= (first %) "#"))
                                            (group-by str (vec forest))))))

(forest-to-outcome (str/join (str/split-lines input)))

(str/join (count (str/split-lines input)))

(defn adjacent-acres
  [acre-number
   max-x
   max-y]
  (let [x (if (<= acre-number max-x) acre-number (if (= 0 (mod acre-number max-x)) max-x (mod acre-number max-x)))
        y (if (<= acre-number max-x) 1 (+ (if (= 0 (mod acre-number max-x)) 0 1) (int (/ acre-number max-x))))
        possible [[(- (- acre-number max-x) 1) (- x 1) (- y 1)]
                  [(- acre-number max-x) x (- y 1)]
                  [(+ (- acre-number max-x) 1) (+ x 1) (- y 1)]
                  [(- acre-number 1) (- x 1) y] [(+ acre-number 1) (+ x 1) y]
                  [(- (+ acre-number max-x) 1) (- x 1) (+ y 1)]
                  [(+ acre-number max-x) x (+ y 1)]
                  [(+ (+ acre-number max-x) 1) (+ x 1) (+ y 1)]]]
    (map first (filter #(and (and (> (second %) 0) (<= (second %) max-x))
                             (and (> (last %) 0) (<= (last %) max-y))) possible))))

(adjacent-acres 18 6 6)

(int (/ 18 6))

(mod 24 6)

[1 2 3 4]

(defn grow
  [input
   seconds]
  (let [lines (str/split-lines input)
        forest (str/join lines)
        max-x (count (first lines))
        max-y (count lines)
        total-acres (* max-x max-y)]
    (loop [acres-left forest
           forest-so-far []
           time-limit 0]
      (if (= time-limit seconds)
        (forest-to-outcome forest)
        (if (empty? acres-left)
          (recur (str forest-so-far) [] (inc time-limit))
          (let [acre-number (+ 1 (- total-acres (count acres-left)))
                possible-adjacent-acres [(- (- acre-number max-x) 1)]]))))))

(grow input 10)
